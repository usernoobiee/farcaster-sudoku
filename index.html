<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <!-- Farcaster / Warpcast Frame metadata (copy exactly) -->
    <meta property="fc:frame" content="vNext">
    <meta property="og:title" content="Mini Sudoku ‚Äî Play inside Farcaster">
    <meta property="og:description" content="Play Sudoku directly inside Warpcast ‚Äî choose difficulty, use hints, and race the timer!">
    <meta property="og:image" content="https://farcaster-sudoku.vercel.app/og-sudoku.png">
    <meta property="og:url" content="https://farcaster-sudoku.vercel.app/">

    <!-- Frame behaviour -->
    <meta property="fc:frame:image" content="https://farcaster-sudoku.vercel.app/og-sudoku.png">
    <meta property="fc:frame:button:1" content="‚ñ∂Ô∏è Play Sudoku">
    <meta property="fc:frame:button:1:action" content="post_redirect">
    <meta property="fc:frame:button:1:url" content="https://farcaster-sudoku.vercel.app/">
    <meta property="fc:frame:post_url" content="https://farcaster-sudoku.vercel.app/">
    <!-- hint: make it explicit the page can be framed -->
    <meta property="fc:frame:allow" content="in_app,fullscreen">


    <title>Mini Sudoku ‚Äî Farcaster Frame</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-1: #071025;
            --bg-2: #041126;
            --muted: #9aa6b2;
            --accent: #7c3aed;
            --accent-2: #6ee7b7;
            --cell-gap: 4px;
            --cell-font: 16px;
            --board-max: 560px; /* reduced to fit embed */
            --grid-border: rgba(255,255,255,0.18);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            margin: 0;
            font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
            color: #dceeff;
            background: linear-gradient(180deg,var(--bg-1) 0%,var(--bg-2) 100%);
            -webkit-font-smoothing: antialiased;
        }

        /* prevent accidental selection while tapping */
        .board, .cell, .numpad {
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }

        .wrap {
            max-width: 900px;
            margin: 12px auto;
            padding: 8px;
        }

        .app {
            background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
            border-radius: 12px;
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.03);
            box-shadow: 0 10px 40px rgba(2,6,23,0.6);
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        h1 {
            font-size: 18px;
            margin: 0;
            font-weight: 800
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }

        select, .btn {
            background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
            border: 1px solid rgba(255,255,255,0.05);
            color: inherit;
            padding: 6px 10px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
        }

        .btn {
            background-image: linear-gradient(180deg,var(--accent),#8257e6);
            color: white;
        }

            .btn.small {
                font-size: 13px;
                padding: 5px 8px
            }

        .board-wrap {
            margin-top: 10px;
            background: rgba(255,255,255,0.02);
            border-radius: 10px;
            padding: 8px;
            border: 1px solid rgba(255,255,255,0.03);
            box-shadow: 0 6px 24px rgba(3,8,20,0.5);
            overflow: hidden;
        }

        /* center board and make responsive */
        .board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: var(--cell-gap);
            width: min(100%, var(--board-max));
            margin: 0 auto;
            touch-action: manipulation;
        }

        .cell {
            background: rgba(255,255,255,0.03);
            aspect-ratio: 1/1;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: var(--cell-font);
            color: #cfe6ff;
            border: 1px solid rgba(255,255,255,0.05);
            position: relative;
            transition: background .08s, box-shadow .08s;
            -webkit-user-select: none;
            cursor: pointer;
        }

            .cell input {
                width: 100%;
                height: 100%;
                text-align: center;
                background: transparent;
                border: none;
                color: inherit;
                font-weight: 800;
                font-size: var(--cell-font);
                outline: none;
                caret-color: var(--accent-2);
            }

        .fixed {
            color: #9ad1ff;
            background: rgba(255,255,255,0.04);
            cursor: default
        }

        .focus {
            box-shadow: 0 0 8px rgba(124,58,237,0.45) inset;
        }

        .wrong {
            background: rgba(139,23,39,0.35)
        }

        /* üß© Stronger 3x3 separators (visual) */
        .cell[data-r="0"] {
            border-top: 2px solid var(--grid-border);
        }

        .cell[data-r="3"] {
            border-top: 2px solid var(--grid-border);
        }

        .cell[data-r="6"] {
            border-top: 2px solid var(--grid-border);
        }

        .cell[data-c="0"] {
            border-left: 2px solid var(--grid-border);
        }

        .cell[data-c="3"] {
            border-left: 2px solid var(--grid-border);
        }

        .cell[data-c="6"] {
            border-left: 2px solid var(--grid-border);
        }

        .cell[data-r="8"] {
            border-bottom: 2px solid var(--grid-border);
        }

        .cell[data-c="8"] {
            border-right: 2px solid var(--grid-border);
        }

        .numpad {
            display: grid;
            grid-template-columns: repeat(9,1fr);
            gap: 8px;
            margin-top: 12px;
        }

        .n-btn {
            background: rgba(255,255,255,0.04);
            border: none;
            border-radius: 8px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #dceeff;
            font-weight: 800;
            font-size: 16px;
            cursor: pointer;
            -webkit-user-select: none;
        }

            .n-btn.primary {
                background: linear-gradient(180deg,var(--accent),#8257e6);
                color: white
            }

        footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            font-size: 13px;
            color: var(--muted);
        }

        /* smaller screens */
        @media(max-width:600px) {
            :root {
                --cell-font: 14px;
                --cell-gap: 3px;
                --board-max: 380px;
            }

            .numpad {
                grid-template-columns: repeat(5,1fr)
            }

            .n-btn {
                height: 40px;
                font-size: 15px;
            }

            .btn {
                font-size: 13px;
                padding: 5px 8px
            }
        }

        /* accessibility focus */
        .cell:focus {
            outline: none;
        }
    </style>
</head>
<body>
    <div class="wrap">
        <div class="app">
            <header>
                <h1>Mini Sudoku ‚Äî Play inside Farcaster</h1>
                <div class="controls">
                    <select id="difficulty" aria-label="Difficulty">
                        <option value="easy">Easy</option>
                        <option value="medium" selected>Medium</option>
                        <option value="hard">Hard</option>
                    </select>
                    <button id="newGame" class="btn">New</button>
                    <button id="check" class="btn small">Check</button>
                    <button id="hint" class="btn small">Hint</button>
                    <button id="solve" class="btn small">Solve</button>
                    <button id="share" class="btn small">Share</button>
                </div>
            </header>

            <div class="board-wrap" role="application" aria-label="Sudoku board">
                <div id="board" class="board" tabindex="0" aria-hidden="false"></div>

                <div class="numpad" id="numpad" aria-hidden="false">
                    <button class="n-btn" data-num="1" aria-label="1">1</button>
                    <button class="n-btn" data-num="2" aria-label="2">2</button>
                    <button class="n-btn" data-num="3" aria-label="3">3</button>
                    <button class="n-btn" data-num="4" aria-label="4">4</button>
                    <button class="n-btn" data-num="5" aria-label="5">5</button>
                    <button class="n-btn" data-num="6" aria-label="6">6</button>
                    <button class="n-btn" data-num="7" aria-label="7">7</button>
                    <button class="n-btn" data-num="8" aria-label="8">8</button>
                    <button class="n-btn" data-num="9" aria-label="9">9</button>
                    <button class="n-btn primary" id="erase" aria-label="erase">Erase</button>
                    <button class="n-btn primary" id="fill" aria-label="hint">Hint</button>
                </div>
            </div>

            <footer>
                <div>‚è± Time: <span id="timer">00:00</span></div>
                <div>Hints: <span id="hints">3</span></div>
            </footer>
        </div>
    </div>

    <script>
        // Utilities
        function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]] } return a; }
        function createEmpty() { return Array.from({ length: 9 }, () => Array(9).fill(0)); }
        function isSafe(g, r, c, n) { for (let d = 0; d < 9; d++) if (g[r][d] === n || g[d][c] === n) return false; const sr = r - r % 3, sc = c - c % 3; for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) if (g[sr + i][sc + j] === n) return false; return true; }
        function copy(g) { return g.map(r => r.slice()) }
        function generateFull() { const g = createEmpty(); const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]; function fill(i) { if (i >= 81) return true; const r = Math.floor(i / 9), c = i % 9; for (const n of shuffle(nums.slice())) if (isSafe(g, r, c, n)) { g[r][c] = n; if (fill(i + 1)) return true; g[r][c] = 0; } return false; } fill(0); return g; }
        function removeCells(grid, diff) { const holes = diff === 'easy' ? 32 : diff === 'hard' ? 44 : 33; const g = copy(grid); const pos = []; for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) pos.push([r, c]); shuffle(pos); for (let i = 0; i < holes; i++) { const [r, c] = pos[i]; g[r][c] = 0; } return g; }

        // DOM + state
        const board = document.getElementById('board');
        let solution, puzzle, fixed, hints = 3, timer = null, start = 0;
        let active = null; // {r,c}
        let lastTapped = null; // index for last tapped cell

        // Timer
        function startTimer() { clearInterval(timer); start = Date.now(); timer = setInterval(() => { const s = Math.floor((Date.now() - start) / 1000); const m = String(Math.floor(s / 60)).padStart(2, '0'); const ss = String(s % 60).padStart(2, '0'); document.getElementById('timer').textContent = `${m}:${ss}`; }, 500); }

        // Render board
        function render(p) {
            board.innerHTML = '';
            fixed = Array.from({ length: 9 }, () => Array(9).fill(false));
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const i = r * 9 + c;
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.dataset.i = i;
                    cell.tabIndex = -1; // allow programmatic focus
                    const v = p[r][c];
                    if (v) {
                        cell.classList.add('fixed');
                        cell.textContent = v;
                        fixed[r][c] = true;
                        // allow clicking fixed cells to highlight row/col if desired
                        cell.addEventListener('click', () => { active = null; lastTapped = i; clearFocusAll(); cell.classList.add('focus'); setTimeout(() => cell.classList.remove('focus'), 300); });
                    } else {
                        const inp = document.createElement('input');
                        inp.type = 'text';
                        inp.maxLength = 1;
                        inp.inputMode = 'numeric';
                        inp.autocomplete = 'off';
                        inp.spellcheck = false;
                        // ensure clicking cell focuses the input (mobile friendly)
                        cell.addEventListener('click', (ev) => { ev.stopPropagation(); inp.focus(); lastTapped = i; });
                        inp.addEventListener('focus', () => { active = { r, c }; cell.classList.add('focus'); lastTapped = i; });
                        inp.addEventListener('blur', () => { cell.classList.remove('focus'); });
                        inp.addEventListener('keydown', e => {
                            if (e.key >= '1' && e.key <= '9') { e.preventDefault(); inp.value = e.key; active = { r, c }; }
                            if (e.key === 'Backspace' || e.key === 'Delete') { e.preventDefault(); inp.value = ''; }
                            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) { e.preventDefault(); move(e.key, r, c); }
                            if (e.key === 'Enter') { e.preventDefault(); check(); }
                        });
                        cell.appendChild(inp);
                    }
                    board.appendChild(cell);
                }
            }
        }

        // utility: remove focus class from all cells
        function clearFocusAll() {
            for (const el of board.children) el.classList.remove('focus');
        }

        // move focus by arrow keys
        function move(k, r, c) {
            if (k === 'ArrowLeft') c--;
            if (k === 'ArrowRight') c++;
            if (k === 'ArrowUp') r--;
            if (k === 'ArrowDown') r++;
            if (r < 0 || c < 0 || r > 8 || c > 8) return;
            const idx = r * 9 + c;
            const targetEl = board.children[idx];
            const inp = targetEl.querySelector('input');
            if (inp) { inp.focus(); active = { r, c }; lastTapped = idx; }
            else {
                // if it's a fixed cell, just set lastTapped and highlight it briefly
                lastTapped = idx;
                clearFocusAll();
                targetEl.classList.add('focus');
                setTimeout(() => targetEl.classList.remove('focus'), 250);
                active = null;
            }
        }

        // gather current grid
        function getGrid() {
            const g = createEmpty();
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const el = board.children[r * 9 + c];
                    const inp = el.querySelector('input');
                    g[r][c] = inp ? +inp.value || 0 : +el.textContent || 0;
                }
            }
            return g;
        }

        // new game
        function newGame(d = 'medium') {
            document.getElementById('difficulty').value = d;
            const full = generateFull();
            solution = copy(full);
            puzzle = removeCells(full, d);
            render(puzzle);
            hints = 3;
            document.getElementById('hints').textContent = hints;
            startTimer();
            active = null;
            lastTapped = null;
        }

        // check solution
        function check() {
            const g = getGrid();
            let ok = true;
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const el = board.children[r * 9 + c];
                    el.classList.remove('wrong');
                    if (g[r][c] !== solution[r][c]) {
                        if (!fixed[r][c]) el.classList.add('wrong');
                        ok = false;
                    }
                }
            }
            alert(ok ? 'üéâ Correct!' : '‚ùå Some cells are wrong or empty.');
        }

        // hint - fill one incorrect or empty cell
        function hint() {
            if (hints <= 0) return alert('No hints left.');
            const g = getGrid();
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (!fixed[r][c] && (!g[r][c] || g[r][c] !== solution[r][c])) {
                        const i = r * 9 + c;
                        const inp = board.children[i].querySelector('input');
                        if (inp) {
                            inp.value = solution[r][c];
                            hints--;
                            document.getElementById('hints').textContent = hints;
                            return;
                        }
                    }
                }
            }
            alert('No hint available');
        }

        // solve all
        function solveAll() {
            for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
                const el = board.children[r * 9 + c];
                const inp = el.querySelector('input');
                if (inp) inp.value = solution[r][c];
            }
        }

        // share
        function share() {
            navigator.clipboard.writeText(`I‚Äôm playing Sudoku inside Farcaster! ${location.href}`).then(() => alert('Copied share text. Paste in Warpcast!'));
        }

        // DOM bindings
        document.getElementById('newGame').onclick = () => newGame(document.getElementById('difficulty').value);
        document.getElementById('check').onclick = check;
        document.getElementById('hint').onclick = hint;
        document.getElementById('solve').onclick = solveAll;
        document.getElementById('share').onclick = share;
        document.getElementById('fill').onclick = hint;
        document.getElementById('erase').onclick = () => {
            if (active) {
                const idx = active.r * 9 + active.c;
                const el = board.children[idx];
                const inp = el.querySelector('input');
                if (inp) inp.value = '';
            } else if (lastTapped !== null) {
                const el = board.children[lastTapped];
                const inp = el.querySelector('input');
                if (inp) inp.value = '';
            }
        };
        document.getElementById('difficulty').onchange = e => newGame(e.target.value);

        // numpad behavior
        document.getElementById('numpad').addEventListener('click', e => {
            const b = e.target.closest('button'); if (!b) return;
            const n = b.dataset.num;
            if (n) {
                // if a cell is active, set there
                if (active) {
                    const idx = active.r * 9 + active.c;
                    const inp = board.children[idx].querySelector('input');
                    if (inp) { inp.value = n; inp.focus(); return; }
                }
                // else prefer lastTapped cell if it's editable
                if (lastTapped !== null) {
                    const inp = board.children[lastTapped].querySelector('input');
                    if (inp) { inp.value = n; inp.focus(); active = { r: Math.floor(lastTapped / 9), c: lastTapped % 9 }; return; }
                }
                // fallback: find first empty editable cell
                for (let i = 0; i < 81; i++) {
                    const inp = board.children[i].querySelector('input');
                    if (inp && !inp.value) { inp.value = n; inp.focus(); active = { r: Math.floor(i / 9), c: i % 9 }; lastTapped = i; break; }
                }
            } else if (b.id === 'erase') {
                // erase
                if (active) {
                    const idx = active.r * 9 + active.c;
                    const inp = board.children[idx].querySelector('input');
                    if (inp) inp.value = '';
                } else if (lastTapped !== null) {
                    const inp = board.children[lastTapped].querySelector('input');
                    if (inp) inp.value = '';
                }
            } else if (b.id === 'fill') {
                hint();
            }
        });

        // click outside board clears active
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.board') && !e.target.closest('.numpad')) { active = null; clearFocusAll(); }
        });

        // initial start
        newGame('medium');

        // expose move to window for debugging if needed
        window.sudokuMove = move;
    </script>
</body>
</html>
